#pragma once
/**
 *  @file attributetraits.H
 *
 *  @brief Templates which map attributes to their type/properties
 *
 *  This header file contains templates which map attributes to their
 *  type/properties.  This file is autogenerated and should not be altered.
 */

//******************************************************************************
// Includes
//******************************************************************************

// STD
#include <stdint.h>
#include <stdlib.h>

// std::array support is dependent on the compiler supporting c++11
#if __cplusplus >= 201103L
#include <array>
#endif

#include <attributestructs.H>
#include <entitypath.H>
namespace TARGETING
{

//******************************************************************************
// Attribute Property Mappings
//******************************************************************************

/**
 *  @brief Template associating a specific attribute with a type and other
 *      properties, such as whether it is readable/writable
 *
 *      This is automatically generated
 *
 *      enum {
 *          disabled = Special value for the basic, unused wildcard attribute
 *          readable = Attribute is readable
 *          writable = Attribute is writable
 *          hasStringConversion = Attribute has debug string conversion
 *      }
 *
 *      typedef <type> TYPE // <type> is the Attribute's valid type
 */
template <const ATTRIBUTE_ID A> class AttributeTraits
{
  private:
    enum
    {
        disabled
    };
    typedef void* Type;
};

template <> class AttributeTraits<ATTR_FAPI_NAME>
{
  public:
    enum
    {
        readable,
        notHbMutex,
        notFspMutex,
        fspAccessible
    };
    typedef char Type[64];
#if __cplusplus >= 201103L
    typedef std::array<char, 64> TypeStdArr;
#endif
};

template <> class AttributeTraits<ATTR_CHIP_ID>
{
  public:
    enum
    {
        writeable,
        readable,
        notHbMutex,
        notFspMutex,
        fspAccessible
    };
    typedef uint32_t Type;
#if __cplusplus >= 201103L
    static constexpr uint32_t CHIP_ID_INVALID = 0xFFFFFFFF;
#endif
};

template <> class AttributeTraits<ATTR_CLOCKSTOP_ON_XSTOP>
{
  public:
    enum
    {
        writeable,
        readable,
        notHbMutex,
        notFspMutex,
        fspAccessible
    };
    typedef uint8_t Type;
#if __cplusplus >= 201103L
    static constexpr uint8_t CLOCKSTOP_ON_XSTOP_INVALID = 0xFF;
#endif
};

template <> class AttributeTraits<ATTR_EC>
{
  public:
    enum
    {
        writeable,
        readable,
        notHbMutex,
        notFspMutex,
        fspAccessible
    };
    typedef uint8_t Type;
#if __cplusplus >= 201103L
    static constexpr uint8_t EC_INVALID = 0xFF;
#endif
};

template <> class AttributeTraits<ATTR_HWAS_STATE>
{
  public:
    enum
    {
        writeable,
        readable,
        notHbMutex,
        notFspMutex,
        fspAccessible
    };
    typedef HwasState Type;
#if __cplusplus >= 201103L
#endif
};

template <> class AttributeTraits<ATTR_LOCATION_CODE>
{
  public:
    enum
    {
        readable,
        notHbMutex,
        notFspMutex,
        fspAccessible
    };
    typedef char Type[64];
#if __cplusplus >= 201103L
    typedef std::array<char, 64> TypeStdArr;
#endif
};

template <> class AttributeTraits<ATTR_NAME>
{
  public:
    enum
    {
        writeable,
        readable,
        notHbMutex,
        notFspMutex,
        fspAccessible
    };
    typedef uint8_t Type;
#if __cplusplus >= 201103L
    static constexpr uint8_t NAME_INVALID = 0xFF;
#endif
};

template <> class AttributeTraits<ATTR_PHYS_DEV_PATH>
{
  public:
    enum
    {
        writeable,
        readable,
        notHbMutex,
        notFspMutex
    };
    typedef std::string Type;
};

template <> class AttributeTraits<ATTR_POSITION>
{
  public:
    enum
    {
        readable,
        notHbMutex,
        notFspMutex,
        fspAccessible
    };
    typedef uint32_t Type;
#if __cplusplus >= 201103L
    static constexpr uint32_t POSITION_INVALID = 0xFFFFFFFF;
#endif
};

template <> class AttributeTraits<ATTR_POS>
{
  public:
    enum
    {
        readable,
        notHbMutex,
        notFspMutex,
        fspAccessible
    };
    typedef uint32_t Type;
#if __cplusplus >= 201103L
    static constexpr uint32_t POS_INVALID = 0xFFFFFFFF;
#endif
};

template <> class AttributeTraits<ATTR_SPI_BUS_DIV_REF>
{
  public:
    enum
    {
        writeable,
        readable,
        notHbMutex,
        notFspMutex,
        fspAccessible
    };
    typedef uint16_t Type;
#if __cplusplus >= 201103L
    static constexpr uint16_t SPI_BUS_DIV_REF_INVALID = 0xFFFF;
#endif
};

template <> class AttributeTraits<ATTR_TYPE>
{
  public:
    enum
    {
        readable,
        hasStringConversion,
        notHbMutex,
        notFspMutex,
        fspAccessible
    };
    typedef uint8_t Type;
#if __cplusplus >= 201103L
    static constexpr uint32_t TYPE_INVALID = 0x7F;
#endif
};

template <> class AttributeTraits<ATTR_PHYS_BIN_PATH>
{
  public:
    enum
    {
        writeable,
        readable,
        notHbMutex,
        notFspMutex
    };
    typedef EntityPath Type;
#if __cplusplus >= 201103L
#endif
};
template <> class AttributeTraits<ATTR_PHYS_PATH>
{
  public:
    enum
    {
        readable,
        notHbMutex,
        notFspMutex,
        fspAccessible
    };
    typedef EntityPath Type;
#if __cplusplus >= 201103L
#endif
};

// Type aliases and/or sizes for ATTR_TYPE attribute
typedef TYPE TYPE_ATTR;
typedef TYPE ATTR_TYPE_type;

// Type aliases and/or sizes for ATTR_ENGINE_TYPE attribute
typedef ENGINE_TYPE ENGINE_TYPE_ATTR;
typedef ENGINE_TYPE ATTR_ENGINE_TYPE_type;

// Type aliases and/or sizes for ATTR_CLASS attribute
typedef CLASS CLASS_ATTR;
typedef CLASS ATTR_CLASS_type;

} // End namespace TARGETING
